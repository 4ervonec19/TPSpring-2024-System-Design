### Базы Данных для раздела "Комментарии к профилю" игровой платформы Steam

> Для проектирования комментариев была выбран реляционный тип базы данных. ***Основные причины***:
1. ***Простота и понятная взаимосвязность*** для объективно не самого сложного раздела. <br><br>
2. Возможность принимать сложные запросы и получать основную информацию о комментариях и пользователях по ***PRIMARY KEY*** или ***ID_{"Вставьте ID того, что вы хотели бы получить"}***. <br><br>
3. ***Высокая нормализация***: База данных разбита на несколько таблиц, связанных внешними ключами, что обеспечивает высокую степень нормализации. Это минимизирует дублирование данных и улучшает целостность данных.<br><br>

4. Реляционные базы данных позволяют создавать индексы на столбцах, что значительно ***повышает*** ***производительность*** запросов. Это особенно полезно для больших объемов данных, где необходимо быстро искать записи.

5. ***Совместимость***: Реляционные базы данных совместимы с широким спектром операционных систем и аппаратных платформ.

### Структура Базы Данных

* ***users*** -  Таблица пользователей:
```sql
Table users 
{
  user_id integer [primary key]
  username varchar [not null]
  avatar_image blob [note: "Image of user's avatar"]
  date_time timestamp [default: 'now()', not null]
}
```
* ***comments*** - Таблица комментов:
```sql
Table comments 
{
  comment_id integer [primary key] 
  date_time timestamp [default: 'now()', not null]
  comment_text varchar [note: "Comment text", not null]
  user_id integer
  report_status bool
  profile_id integer [note: "ID of the profile to view commetns under"]
}
```

* ***follows*** - Таблица подписок:
```sql
Table follows
{
  subscriber_id integer 
  subscribed_on_id integer [note: "User on which's comments subscribed"]
  date_time timestamp  [default: 'now()', not null]
}
```
![](Comment_profiles\png_database.png)


### Нереляционный формат: ***Документоориентированная База Данных***.

* Позволяет избавиться от дублирования поля  ***profile_id***, по которому и будут запрашиваться комментарии под страницей и облегчить понимание структуры. То есть по profile_id нужно раскидать всё по JSON-файлам.

![Документоориентированная БД](Comment_profiles\document_type_db.png)

* Недостатки могут крыться в сложном доступе к конкретным комментариям, записи и хранении таких баз данных.

### Рассчёт размера хранимых данных в ***реляционной архитектуре***

#### Предположения:
* Число пользователей = 1.000.000 <br>
* Среднее число комментариев под профилем $\approx$ 10.
* Сколько подписок? Ну, я не думаю, что данная фича пользуется огромной популярностью, поэтому давайте положим, что у каждого пользователя 1-2 подписки на других $\implies$ 1.5 x 1.000.000 = 1.500.000. 

#### Размеры таблиц:

1. ***Users***:

* ```user_id ```:  4 байта
* ```username```: 32 байта
* ```avatar_image```: 3072 байта (принимаем 32 х 32 х 3)
* ```date_time```: 8 байт

>На пользователя - 3116 байт <br>
>На всю таблицу - 2,9 ГБ.

2. ***Comments***:

* ```comment_id```: 4 байта
* ```user_id```: 4 байта
* ```profile_id```: 4 байта
* ```date_time```: 8 байт
* ```report status```: 1 байт
* ```comment_text```: 1000 байт (Условные 1000 символов)

>На комментарий - 1021 байт <br>
>На всю таблицу - 0,95 ГБ.

3. ***Follows***

* ```subscriber_id```: 4 байта
* ```subscribed_on_id```: 4 байта
* ```date_time```: 8 байт

>На запись - 16 байт <br>
>На всю таблицу - 0,023 ГБ.

> ***Итого***: 3,873 ГБ.

### Потенциально ***узкие места***:

* Подгрузка изображений аватарок из таблицы ***users*** ввиду их значительного веса. Возможно, стоит хранить их в отдельной БД ключ-значение, где ключом будет выступать User. Вероятно, также стоит хранить картинки в сжатом архивированном формате с применением алгоритмов (Дерево Хаффмана, которое мы изучали в курсе Алгоритмов и Структур Данных, например). Или можно попытаться закэшировать аватарки.

* Поле ***report_status*** можеть быть лишним в таблице ***comments***. Есть смысл просто организовать удаление коммента по запросу его ***id*** без учёта булевых переменных.

* В нашем примере таблица ***follows*** содержит 1,5 миллиона подписок. Но в реальности их может быть гораздо больше для тех же полутора миллионов (max: 999.999 x 1.000.000). Поэтому нужно как-то оптимизировать поиск для отправки уведомлений пользователям, которые подписаны на user'а-источник. Например, можно раздробить данную таблицу на несколько, тем самым распараллелив поиск.

### ***Кэш?***

***Зачем нужен кэш?*** Основное назначение кэша - ускорить доступ к наиболее востребованным данным, особенно агрегированным. Можно использовать Redis или Memcached.

***Какие данные кэшировать?***

1. Аватарки пользователей

* Ключ - user_id; Значение - изображение аватарки.

2. Текста комментариев.

* Ключ: {profile_id}{comment_id}; Значение - текст комментария.

3. Также в реализации Документориентированной Базы Данных можно попробовать кэшировать целые страницы:

* Ключ: profile_id; Значение : JSON-формат страницы.

#### Заполнение кэша:

##### При запросе данных:

* Проверять кэш перед выполнением запроса. <br>
* Если данные не найдены, выполнить запрос к базе данных, затем записать результат в кэш.


##### Обновление кэша:

* При обновлении базы данных (новые покупки, отзывы) обновлять соответствующие ключи в кэше.
* Использовать механизм TTL (Time-To-Live) для автоматического удаления устаревших данных.



