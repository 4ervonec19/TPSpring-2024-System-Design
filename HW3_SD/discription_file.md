# Домашнее задание №3 по дисциплине "Системный дизайн" #

* Группа: ML-12
* Студент: Червоников Алексей
* Команда: < 2M / 2A >

## Задание 3.1. ##

### Short Review ###

> Задание заключается в рассмотрении постановки задач по разным уровням для выбранного функционала. Я выбрал рассмотрение <u>системы трансляций от разработчика</u>. Рассмотрение по уровням выглядит следующим образом:
<br>
* <u>По алгоритму</u> (для junior-разработчика):<br>
<br>
Показываем и рассказываем неопытному джуну, что мы проектируем, какая бизнес-проблема решается, зачем всё это нужно. Потом мы рассказываем, как мы эту проблему решаем. Затем джуну делаем конкретную методичку: делай, что нужно; что не нужно - не делай. Творческой свободы у джуна нет. Ему нужно написатть конкретные шаги (разжевать и в рот положить, чтобы он всё это качественно обработал).

* <u>По результату</u> (для middle-разработчиков):<br>
<br>
Middle-разработчику рассказываем какая у нас бизнес-проблема и говорит в общем смысле как мы её будем решать. А то, какими правдами и неправдами мы к этому решению прийдём лежит полностью на плечах сотрудника. Итак, отличие от постановки по алгоритму в том, что мы не рассказываем разработчику конкретные шаги и методику решения проблемы, а доверяем это непосрдественно его скиллами и компетенции.

* <u>По проблеме</u> (для senior-разработчиков): <br>
Бизнес обозначет проблему. А что будет являться решением и какие маниупляции надо сделать, чтобы прийти к результату - всё в руках разработчика.

> Итак, подобное нам нужно сделать и для нашей функциональности. Согласно ТЗ: нужно построить правильное решение + неправильное. Формат для данного пункта - ***свободный***.

### Решение ###

1. По алгоритму: <br>
* <u>Бизнес-проблема</u>: <br>
Мы проектируем систему трансляций от разработчика. Проектируемая система выполняет задачу трансляции процесса игры от разработчиков, которую можно найти на странице игры или в соответствующем разделе сообщества. Кроме того, мы хотим, чтобы приходило уведомление о начале трансляции пользователям, у которых конкретная игра находится в вишлисте и была возможность скачать запись трансляции в течение некоторого времени после окончания вещания. Это нужно для повышения выручки с продажи игр, поскольку трансляция - лучший способ склонить игрока к покупке, продемонстрировав лучшие качества продукта. Также ожидается повышение охвата трансляций. (Рассказ джуну о том, что мы делаем и зачем). <br>
* <u>Как мы планируем решать данную проблему</u>: <br>
Полагается, что видео загружается из приложения для трансляция (например, OBS). После через систему балансировщика, брокера сообщений и кодировщика видео, приводящего данные в определённый формат. После непосредственно и начинается ядро нашей функциональности: микросервис распределения. Его основные задачи - реализация связи данных с системой кэширования, Content Delivery Network (Для распределения трансляций в облачных сервисах по регионам и территориям) и облачным хранилищем для загрузки; реализация связи с БД игр и адресами трансляций, с помощью которой и будет происходить взаимодействие с внешними системами. Помимо существует микросервис оповещения, который берет данные из той же БД, из магазина и передаёт сигнал системе уведомлений, оповещающей пользователя. В общих чертах концепция имеет такой вид.
* <u>Алгоритм для джуна: Что тебе надо сделать</u> :
1. Видеоряд идёт из внешнего приложения, например, OBS. Необходимо на данном этапе интегрировать в нашу систему балансировщик нагрузок, брокер сообщение (прописать их вызов) и реализовать видео-энкодер. Необходимо реализовать в рамках контейнера алгоритм сжатия данных. Например, с помощью дискретного косинусного преобразования или упаковки в контейнер (MP4 или AVI). 

2. Смотри, дружище. Тебе на вход приходят данные (кадры видео), название игры, ссылки-адреса трансляций. Твоя задача через GamesRepository сделать механизм записи этих полей в соответствующую БД - БД игр и трансляций. Это нужно для того, чтобы в случае существования трансляции, API сервис забирал инфу о ней и забирал данные из облачного хранилища или направлял запросы в CDN, чтобы тот передавал загруженные из кэша данные. Это можешь реализовать через SQL-запросы и взаимодействие с БД PostgreSQL.

3. Далее, мы хотим чуть ли не за O(1) загружать видео. Тебе нужно реализовать механизм кэширования данных. И через репозиторий CashRepository забирает данные из кэша, например. Условно: ссылка - ключ, значение - видео. 

4. Следующим шагом нужно реализовать компоненту CDN:
внутри должен быть реализован механизм забора данных из кэша, по ссылке идущей из микросервиса распределения (Нужно реализовать это через CDNRepository). Допустим, тот же забор значения по ключу. Условно будет забирать данные видео по ссылке за "быстро". В рамках CDN необходимо реализовать алгоритмы масштабирования, динамической маршрутизации, прогнозирования нагрузки в рамках взаимодействия с серверами.

5. Затем мы хотим реализовать загрузку данных. Для этого тебе нужно свзязываться с облачным сервисом через DistributionService и через соответствующий репозиторий получать команду на загрузку файлов и обращаться к кэшу за данными. Условный псевдокод:
```python
if flag_download(link) == 1:
    video_data = get_from_cash(link) #through repository
    create_in_cloud(link, video_data) # data + link fields
else:
    return
```
5. Следующим шагом реализуй API-сервис (касательно нашей задачи), внутренняя логика которого выглядит следующим образом (псевдокод):
```python
if broadcast in GamesDatabase:
    link = get_link_from_GamesDatabase(broadcast) #Взять ссылку из БД
    query_to_CDN(link) #Сделать запрос в БД
    data = get_from_CDN(link) #Берем данные по значению ссылки из CDN
    pass_to_API(data) #Ведём данные к API
    pass_from_api_to_external_systems(data) #И отправляем во внешние системы
    if flag_external_download(link) ==  1: # если есть запрос на загрузку
        query_to_cloud(link) #Запрос в БД по адресу
        data_from_cloud = get_from_cloud(link) #Забор данных из облака
        pass_to_API(data_from_cloud) #Ведём данные к API
        pass_from_api_to_external_systems(data_from_cloud) #Через него к внешним системам
        start_download_process(data_from_cloud) #Ну и там какой-то процесс загрузки
```
В API-сервисе реализуй запросы в БД игр и взаимодействие с CDN (запрос-чтение). То есть бизнес-логика следующая: Если новая трансляция в БД появилась, то берём её адрес и с ним идём в CDN через апишник. CDN-овская логика берет эту ссылку и получает по этому ключу данные о видео. Далее эти данные прогоняем обратно к апишнику и передаём во внешние системы. Если извне пришёл запрос на загрузку, то условно зажигаем флаг потребности в загрузке и по адресу забираем данные из облака (через запрос в БД, например). Далее прогоняем через апишник и где-то во внешней системе начинается загрузка. Как-то так. <br>

Далее, у нас в планах механизм оповещения игрока о старте трансляции, если игра в вишлисте. Для этого нужно предусмотреть следующие этапы реализации:

1. Когда началась новая трансляция, микросервис оповещения должен сделать запрос в БД и забрать оттуда поле игры и ссылки. Всё это делается через запросы в БД и этот момент можно отслеживать, например, через взаимодействие микросервиса распрделения и оповещения. Условно (псевдокод):
```python
new_link_flag = distribution(new_link) #распределение дало флаг 1 на новую ссылку
if new_link_flag: #Если новая ссылка
    game = notification_get_game(new_link) #вернем игру
```
2. Далее с этой игрой нужно пойти через RequestService в раздел магазина (вишлиста) и получить из условной БД ID, UserName тех юзеров, у которых эта игра в вишлисте (внешняя система).
3. Далее нужно реализовать связку уведомлений через микросервис оповещений. Это можно сделать следующим образом:
```python
tuples_users = [(element[0], element[1], element[2], element[3]) for element in zip(game, id, username, link)] # Условно инфа об игре, соответствующем пользователе, его id, ссылке на игру
for data in tuples_users:
    notification = f"Game {data[0]} started the broadcast. Dear {data[2]}, join us via link {data[3]}!" # Формируем строку уведомления.
    pass_through_notifications_queue(notification) # Добавляем в очередь сообщения
    pass_to_the_external_system(notification) # Передача во внешний сервис, уведомляющий пользователя.
```

So, something like that.

2. По результату: <br>
* <u>Бизнес-проблема</u>: <br>
Мы проектируем систему трансляций от разработчика. Нужно реализовать показ трансляций, также хотим добавить возможность загружать видео-трансляции по окончании и отправлять уведомление тем юзерам, у которых игра в вишлисте. Это нужно для повышения выручки с продажи игр, поскольку трансляция - лучший способ склонить игрока к покупке, продемонстрировав лучшие качества продукта. Также ожидается повышение охвата трансляций. (Рассказ мидлу о том, что мы делаем и зачем). <br>

* <u>Как мы планиурем решать эту проблему</u>: <br>
Смотри, пусть у нас видео приходит через OBS. Перед входом в нашу систему оно должно пройти кодировку для предоставления данных в нужном формате. Далее следует записать данные о трансляции в базу данных игр, где будет храниться игра и ссылка. Мы будем загружать данные через сервис CDN по ссылке из сервиса распределения, CDN подгружает данные из кэша (туда сохраняются видео). Нужно реализовать внутренние сервисы CDN. Также для реализации загрузки нужно записывать данные из кэша в облачный сервис по ссылке из сервиса распределения. Когда трансляция началась - апишник забирает ссылку -  направляет её в CDN и забирает видео-ряд. Если есть запрос на загрузку - апишник передаёт этот запрос и забирает данные из облака. Также делаем систему оповещений. Распределение передаёт факт наличия новой трансляции в БД игр. Сервис забирает игру и через магазин запрашивает список юзеров, для которых эта игра в вишлисте. Потом нам нужно этим людям передать уведомление о начале эфира.
3. По проблеме: <br>

* <u>Постановка бизнес-задачи</u>: <br>

Дорогой senior, мы планируем разработать систему показа трансляций от разработчика. Показ игры - лучший способ её продать. Также мы хотим сделать фичу, сущность которой заключается в следующем: должно приходить уведомление пользователям, для которых транслируемая находится в вишлисте. Хотелось бы иметь возможность загрузить видео трансляции по её окончании. Как-то так. Такой функционал необходимо реализовать.

### Небольшой анализ решения и реализация лучшего варианта ###

>Говоря про реализацию постановки бизнес-проблемы и словесного пути решения сложно придумать какие-то подводные камни для данной задачи, однако, на мой взгляд, лучше будет произвести форматирование Технического Задания для разработчика. Формат хоть и ***свободный***, но лучше соблюсти момент формальных рамок. <br>
<br>
Если мы говорим про техническую часть задания, то думаю, что постановка задач **без** использования ***ООП*** может прослыть дурным тоном и другим разработчикам более высокого грейда будет мучительно разобраться в коде, который написал джун. Поэтому склоняюсь к тому, что стоит реализовать постановку задачи по алгоритму в терминах конкретных ***классов, атрибутов и методов***.

### Скорректированное решение ###

1. По алгоритму
* <u>***Постановка бизнес-задачи***</u>: <br>
    * ***Техническое Задание***: Проектирование системы трансляций от разработчка игровой платформы Steam.
    * ***Функциональные требования***:
        * **Показ** трансляции от разработчика в разделе Магазин, Сообщество или Страница игры.
        * Получение **уведомления** о начале трансляции, если у пользователя игра в вишлисте.
        * Возможность **скачать** запись трансляции в течение определённого момента времени после её окончания.
    
    * ***Ценность функционала***:
        * Повышение **охвата** трансляции.
        * Потенциальная **прибыль** для компании за счёт повышения продаж игр. Полагается, что просмотр трансляции продукта поможет наконец-таки решиться пользователю и приобрести её.
    
* <u> ***RoadMap решения***</u>: 
    * Поток данных приходит из внешнего приложения, например ***OBS***.
    * Происходит ***балансировка нагрузки*** и данные попадают в очередь (***брокер сообщений***).
    
    * ***Кодировщик*** приводит данные в необходимый формат для последующей обработки в **микросервисной архитектуре**.
    
    * ***Микросервис распределения*** направляет данные о потоке и действиях через репозитории в **контейнеры**:
        * ***Кэш*** (Кэширует данные по ссылке).
        * ***Content Delievery Network*** (Получает ссылку, по которой подгружает данные из кэша, внутрення логика распределяет данные по регионам).
        * ***БД игр и адресов*** (Сохраняет ссылку и название игр трансляций).
        * ***Cloud Service*** (Получает команду о подгрузке данных из кэша).
    
    * ***API-сервис*** управляет взаимодеействием с внешними системами (Магазин, Страница игры):
        * Слушает **обновление БД** и забирает ссылку.
        * Отправляет ссылку в **CDN**, по которой забираются данные.
        * В случае запроса на загрузку направляет ссылку в **Cloud Service**. Забирает данные для загрузки.
    * ***Микросервис оповещения*** уведомляет пользователей о начале эфира:
        * Слушает **обновление БД** о начале нового потока и берет игру. 
        * Связывается с внешним **магазином** и получает **список пользователей**.
        * По данному списку через очередь **осуществляет рассылку уведомлений**.

* <u> ***Алгоритм решения***</u>: 
1. Настроить получение потока из ***OBS*** по протоколу ***RTSP***. Прописать ***Load Balancer (NginX)*** и ***брокер сообщений (Kafka)***.
2. Реализовать ***алгоритм кодировки*** формата видео для сжатия данных и перевода в нужный формат (***MP4*** или ***AVI***) Псевдокод:
```python
class VideoEncoder:
    def __init__(self, output_file = 'broadcast.mp4', *args, **kwargs):
        self.codec = fourcc(*"mp4v") # Формат видео-кодека
        self.out = VideoWriter(output_file, self.codec, *args, **kwargs) # Объект, куда будет записваться поток

    def encode_frame(self, frame):
        self.out.write(frame) # Кодирование кадра и запись
    
    def free_encoder(self):
        self.out.free() #Освободить ресурсы
    
    def save(self):
        self.out.save()

if __name__ == '__main__':
    data = 'link_data.format'
    encoder = VideoEncoder()
    for frame in data:
        encoder.encode_frame(frame)
    
    encoder.save()
    encoder.free()

# Внутренняя логика кодировщика
```
Пусть, есть класс **VideoEncoder**, который имеет атрибуты **codec** (формат) и **out** (то, что является результатом кодировки). Метод **encode_frame** записывает закодированный кадр, **free_encoder** - освобождает ресурсы, **save** - сохраняет для передачи в систему. Покадрово будет кодироваться видео, потом сохраняться и передавться по протоколу через брокер сообщений в систему. Тебе нужно превратить псевдокод в реализацию.

3. Реализовать внутреннюю логику ***микросервиса распределения***. 
* Запись в ***Кэш***.
```python
class VideoCacher:
    def __init__(self, link, data, cash_directory, *args, **kwargs):
        self.cache_dir = cash_directory # Файл/папка куда пишем кэш
        self.data = data
        self.link = link
        self.frames = {} # Словарь сслыка - видео

    def start_cache(self):
        self.frames[self.link] = [] # Новая запись

    def add_frame(self, frame):
        temp_frame_path = get_path(self.cash_dir) #Куда в этой директории будет писать кэш
        write(temp_frame_path, frame) #Записываем в кэш
        self.frames[link].append(temp_frame_path) # Добавляем ссылку на кадр.
    
    def write_cache(self): #Покадрово записать данные в кэш
        for frame in self.data:
            add_frame(frame)
    
    def clear_cache(self, link):
        clear_cache(link) #Очистка после чтения

if __name__ == '__main__':
    cache = VideoCacher(link, data, cash_directory)
    cache.start_cache()
    cache.write_cache() 

# Логика записи в кэш-память
```
Создаём класс **VideoCacher**, который будет записывать данные **link**<->**data** в **директорию cash_directory**. Соответственно перед началом кэширования будет объявляться по ключу массив ссылок на кадры. Это метод ***start_cache***. Затем покадрово делаем ***write_cache*** с использованием ***add_frame***. Чтение будет делать **Google Cloud** и **CDN**. Потом будет очищаться память. 
* Запись в ***БД игр и ссылок***.
```python 
class BroadcastInfo:
    def __init__(self, name, link):
        self.name = name
        self.link = link
    
    def empty_instance(self):
        if self.name != '':
            return True
        else:
            return False
    
if __name__ == '__main__':
    broadcast = BroadcastInfo(name, link) # Экземпляр класса инфо о трансляции
    directory_db = directory #Ссылка на БД
    insert_query = "INSERT INTO games (name, link) VALUES (%s, %s)"
    execute(insert_query, directory_db, (broadcast.name, broadcast.link)) # Записываем данные по сслыке
    close_connection() #Останавливаем соединение
```
* Также необходимо добавить ***подгрузку данных в облако Google Cloud*** при начале новой трансляции. Это можно сделать добавив дополнительную логику к предыдщему коду:
```python
    if broadcast.empty_instance() == True:
        read_query = f"SELECT * FROM cache WHERE link = '{broadcast.link}'"
        data = execute(read_query, cache_dir)
        write_in_cloud(broadcast.link, data) # Что-то вроде реализации записи в облако, откуда мы будем загружать
        # Соответственно нужно настроить связь с облачным сервисом
```
* ***Content Delievery Network*** будет получать ***link*** от broadcast и подгружать по этому ***link*** данные из ***кэша***.
```python
# Реализуется при помощи стандартных библиотек
import send_from_directory

@app.route('/content/<path:link>') 
def content():
    send_from_directory(cache_dir, broadcast.link) # Читает из кэша

if __name__ == '__main__':
    app.run(host = '0.0.0.0', port = 80)

# Какая-то такая реализация подгрузки данных из кэша
```
4. Реализовать ***API-сервис*** с внутренней логикой: загрузка данных из **Google Cloud**, **CDN** и **прослушивание обновления БД игр** для забора линков. Он же будет передвать инфу во внешние сервисы.
```python
@app.route('/get-new-record-link', methods = ['GET'])
def API():
    connection = get_games_db_connection(params_games)
    execute('SELECT link FROM games ORDER BY id DESC LIMIT 1;')
    link_new = execute.result # Получили новую запись (линк)
    connection.close() # Стоп-connection
    
    connection_cdn = get_cdn(params_cdn) # Подключаемся к CDN
    data = get_data_from_cdn(link_new) # Запрашиваем данные по ссылке
    connection_cdn.close() # Стоп-connection

    send_data(data, external_link) # Отправляем поток через API по внешней ссылке

    signal = input_signal # Флаговый сигнал на загрузку
    link_download = link_download # Ссылка в cloud
    if signal == true:
        connection_cloud = get_cloud(params_cloud) # Коннект к облаку
        data = get_data_from_cloud(link_download) # берем данные
        send_data(data, external_link) # во внешнюю систему
        connection_cloud.close() # Стоп-connection
        
if __name__ == '__main__':
    app.run(debug = True)

# Общая примерная реализация (Без углубленных знаний бэкэнда). 
```
Так, необходимо прописать на уровне ***API*** просмотр ***БД*** игр, забирать оттуда ссылку, по которой будем брать данные из ***CDN*** и отправлять куда-то во вне. Также на вход будет поступать извне ***signal*** начала загрузки по ссылке, после чего будет загружаться файл (во внешней системе).

5. Реализовать ***систему уведомлений***:




    

    
    
    



