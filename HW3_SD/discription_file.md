# Домашнее задание №3 по дисциплине "Системный дизайн" #

* Группа: ML-12
* Студент: Червоников Алексей
* Команда: < 2M / 2A >

## Задание 3.1. ##

### Short Review ###

> Задание заключается в рассмотрении постановки задач по разным уровням для выбранного функционала. Я выбрал рассмотрение <u>системы трансляций от разработчика</u>. Рассмотрение по уровням выглядит следующим образом:

* <u>По алгоритму</u> (для junior-разработчика):<br>
<br>
Показываем и рассказываем неопытному джуну, что мы проектируем, какая бизнес-проблема решается, зачем всё это нужно. Потом мы рассказываем, как мы эту проблему решаем. Затем джуну делаем конкретную методичку: делай, что нужно; что не нужно - не делай. Творческой свободы у джуна нет. Ему нужно написатть конкретные шаги (разжевать и в рот положить, чтобы он всё это качественно обработал).

* <u>По результату</u> (для middle-разработчиков):<br>
<br>
Middle-разработчику рассказываем какая у нас бизнес-проблема и говорит в общем смысле как мы её будем решать. А то, какими правдами и неправдами мы к этому решению прийдём лежит полностью на плечах сотрудника. Итак, отличие от постановки по алгоритму в том, что мы не рассказываем разработчику конкретные шаги и методику решения проблемы, а доверяем это непосрдественно его скиллами и компетенции.

* <u>По проблеме</u> (для senior-разработчиков): <br>
Бизнес обозначет проблему. А что будет являться решением и какие маниупляции надо сделать, чтобы прийти к результату - всё в руках разработчика.

> Итак, подобное нам нужно сделать и для нашей функциональности. Согласно ТЗ: нужно построить правильное решение + неправильное. Формат для данного пункта - ***свободный***.

### Решение ###

1. По алгоритму: <br>
* <u>Бизнес-проблема</u>: <br>
Мы проектируем систему трансляций от разработчика. Проектируемая система выполняет задачу трансляции процесса игры от разработчиков, которую можно найти на странице игры или в соответствующем разделе сообщества. Кроме того, мы хотим, чтобы приходило уведомление о начале трансляции пользователям, у которых конкретная игра находится в вишлисте и была возможность скачать запись трансляции в течение некоторого времени после окончания вещания. Это нужно для повышения выручки с продажи игр, поскольку трансляция - лучший способ склонить игрока к покупке, продемонстрировав лучшие качества продукта. Также ожидается повышение охвата трансляций. (Рассказ джуну о том, что мы делаем и зачем). <br>
* <u>Как мы планируем решать данную проблему</u>: <br>
Полагается, что видео загружается из приложения для трансляция (например, OBS). После через систему балансировщика, брокера сообщений и кодировщика видео, приводящего данные в определённый формат. После непосредственно и начинается ядро нашей функциональности: микросервис распределения. Его основные задачи - реализация связи данных с системой кэширования, Content Delivery Network (Для распределения трансляций в облачных сервисах по регионам и территориям) и облачным хранилищем для загрузки; реализация связи с БД игр и адресами трансляций, с помощью которой и будет происходить взаимодействие с внешними системами. Помимо существует микросервис оповещения, который берет данные из той же БД, из магазина и передаёт сигнал системе уведомлений, оповещающей пользователя. В общих чертах концепция имеет такой вид.
* <u>Алгоритм для джуна: Что тебе надо сделать</u> :
1. Видеоряд идёт из внешнего приложения, например, OBS. Необходимо на данном этапе интегрировать в нашу систему балансировщик нагрузок, брокер сообщение (прописать их вызов) и реализовать видео-энкодер. Необходимо реализовать в рамках контейнера алгоритм сжатия данных. Например, с помощью дискретного косинусного преобразования или упаковки в контейнер (MP4 или AVI). 

2. Смотри, дружище. Тебе на вход приходят данные (кадры видео), название игры, ссылки-адреса трансляций. Твоя задача через GamesRepository сделать механизм записи этих полей в соответствующую БД - БД игр и трансляций. Это нужно для того, чтобы в случае существования трансляции, API сервис забирал инфу о ней и забирал данные из облачного хранилища или направлял запросы в CDN, чтобы тот передавал загруженные из кэша данные. Это можешь реализовать через SQL-запросы и взаимодействие с БД PostgreSQL.

3. Далее, мы хотим чуть ли не за O(1) загружать видео. Тебе нужно реализовать механизм кэширования данных. И через репозиторий CashRepository забирает данные из кэша, например. Условно: ссылка - ключ, значение - видео. 

4. Следующим шагом нужно реализовать компоненту CDN:
внутри должен быть реализован механизм забора данных из кэша, по ссылке идущей из микросервиса распределения (Нужно реализовать это через CDNRepository). Допустим, тот же забор значения по ключу. Условно будет забирать данные видео по ссылке за "быстро". В рамках CDN необходимо реализовать алгоритмы масштабирования, динамической маршрутизации, прогнозирования нагрузки в рамках взаимодействия с серверами.

5. Затем мы хотим реализовать загрузку данных. Для этого тебе нужно свзязываться с облачным сервисом через DistributionService и через соответствующий репозиторий получать команду на загрузку файлов и обращаться к кэшу за данными. Условный псевдокод:
```python
if flag_download(link) == 1:
    video_data = get_from_cash(link) #through repository
    create_in_cloud(link, video_data) # data + link fields
else:
    return
```
6. Следующим шагом реализуй API-сервис (касательно нашей задачи), внутренняя логика которого выглядит следующим образом (псевдокод):
```python
if broadcast in GamesDatabase:
    link = get_link_from_GamesDatabase(broadcast) #Взять ссылку из БД
    query_to_CDN(link) #Сделать запрос в БД
    data = get_from_CDN(link) #Берем данные по значению ссылки из CDN
    pass_to_API(data) #Ведём данные к API
    pass_from_api_to_external_systems(data) #И отправляем во внешние системы
    if flag_external_download(link) ==  1: # если есть запрос на загрузку
        query_to_cloud(link) #Запрос в БД по адресу
        data_from_cloud = get_from_cloud(link) #Забор данных из облака
        pass_to_API(data_from_cloud) #Ведём данные к API
        pass_from_api_to_external_systems(data_from_cloud) #Через него к внешним системам
        start_download_process(data_from_cloud) #Ну и там какой-то процесс загрузки
```
В API-сервисе реализуй запросы в БД игр и взаимодействие с CDN (запрос-чтение). То есть бизнес-логика следующая: Если новая трансляция в БД появилась, то берём её адрес и с ним идём в CDN через апишник. CDN-овская логика берет эту ссылку и получает по этому ключу данные о видео. Далее эти данные прогоняем обратно к апишнику и передаём во внешние системы. Если извне пришёл запрос на загрузку, то условно зажигаем флаг потребности в загрузке и по адресу забираем данные из облака (через запрос в БД, например). Далее прогоняем через апишник и где-то во внешней системе начинается загрузка. Как-то так. <br>

Далее, у нас в планах механизм оповещения игрока о старте трансляции, если игра в вишлисте. Для этого нужно предусмотреть следующие этапы реализации:

1. Когда началась новая трансляция, микросервис оповещения должен сделать запрос в БД и забрать оттуда поле игры и ссылки. Всё это делается через запросы в БД и этот момент можно отслеживать, например, через взаимодействие микросервиса распрделения и оповещения. Условно (псевдокод):
```python
new_link_flag = distribution(new_link) #распределение дало флаг 1 на новую ссылку
if new_link_flag: #Если новая ссылка
    game = notification_get_game(new_link) #вернем игру
```
2. Далее с этой игрой нужно пойти через RequestService в раздел магазина (вишлиста) и получить из условной БД ID, UserName тех юзеров, у которых эта игра в вишлисте (внешняя система).
3. Далее нужно реализовать связку уведомлений через микросервис оповещений. Это можно сделать следующим образом:
```python
tuples_users = [(element[0], element[1], element[2], element[3]) for element in zip(game, id, username, link)] # Условно инфа об игре, соответствующем пользователе, его id, ссылке на игру
for data in tuples_users:
    notification = f"Game {data[0]} started the broadcast. Dear {data[2]}, join us via link {data[3]}!" # Формируем строку уведомления.
    pass_through_notifications_queue(notification) # Добавляем в очередь сообщения
    pass_to_the_external_system(notification) # Передача во внешний сервис, уведомляющий пользователя.
```

So, something like that.

2. По результату: <br>
* <u>Бизнес-проблема</u>: <br>
Мы проектируем систему трансляций от разработчика. Нужно реализовать показ трансляций, также хотим добавить возможность загружать видео-трансляции по окончании и отправлять уведомление тем юзерам, у которых игра в вишлисте. Это нужно для повышения выручки с продажи игр, поскольку трансляция - лучший способ склонить игрока к покупке, продемонстрировав лучшие качества продукта. Также ожидается повышение охвата трансляций. (Рассказ мидлу о том, что мы делаем и зачем). <br>

* <u>Как мы планиурем решать эту проблему</u>: <br>
Смотри, пусть у нас видео приходит через OBS. Перед входом в нашу систему оно должно пройти кодировку для предоставления данных в нужном формате. Далее следует записать данные о трансляции в базу данных игр, где будет храниться игра и ссылка. Мы будем загружать данные через сервис CDN по ссылке из сервиса распределения, CDN подгружает данные из кэша (туда сохраняются видео). Нужно реализовать внутренние сервисы CDN. Также для реализации загрузки нужно записывать данные из кэша в облачный сервис по ссылке из сервиса распределения. Когда трансляция началась - апишник забирает ссылку -  направляет её в CDN и забирает видео-ряд. Если есть запрос на загрузку - апишник передаёт этот запрос и забирает данные из облака. Также делаем систему оповещений. Распределение передаёт факт наличия новой трансляции в БД игр. Сервис забирает игру и через магазин запрашивает список юзеров, для которых эта игра в вишлисте. Потом нам нужно этим людям передать уведомление о начале эфира.
3. По проблеме: <br>

* <u>Постановка бизнес-задачи</u>: <br>

Дорогой senior, мы планируем разработать систему показа трансляций от разработчика. Показ игры - лучший способ её продать. Также мы хотим сделать фичу, сущность которой заключается в следующем: должно приходить уведомление пользователям, для которых транслируемая находится в вишлисте. Хотелось бы иметь возможность загрузить видео трансляции по её окончании. Как-то так. Такой функционал необходимо реализовать.

### Небольшой анализ решения и реализация лучшего варианта ###

>Говоря про реализацию постановки бизнес-проблемы и словесного пути решения сложно придумать какие-то подводные камни для данной задачи, однако, на мой взгляд, лучше будет произвести форматирование Технического Задания для разработчика. Формат хоть и ***свободный***, но лучше соблюсти момент формальных рамок. <br>
<br>
Если мы говорим про техническую часть задания, то думаю, что постановка задач **без** использования ***ООП*** может прослыть дурным тоном и другим разработчикам более высокого грейда будет мучительно разобраться в коде, который написал джун. Поэтому склоняюсь к тому, что стоит реализовать постановку задачи по алгоритму в терминах конкретных ***классов, атрибутов и методов*** или применение отдельных ***функций***.

### Скорректированное решение ###

1. По алгоритму
* <u>***Постановка бизнес-задачи***</u>: <br>
    * ***Техническое Задание***: Проектирование системы трансляций от разработчка игровой платформы Steam.
    * ***Функциональные требования***:
        * **Показ** трансляции от разработчика в разделе Магазин, Сообщество или Страница игры.
        * Получение **уведомления** о начале трансляции, если у пользователя игра в вишлисте.
        * Возможность **скачать** запись трансляции в течение определённого момента времени после её окончания.
    
    * ***Ценность функционала***:
        * Повышение **охвата** трансляции.
        * Потенциальная **прибыль** для компании за счёт повышения продаж игр. Полагается, что просмотр трансляции продукта поможет наконец-таки решиться пользователю и приобрести её.
    
* <u> ***RoadMap решения***</u>: 
    * Поток данных приходит из внешнего приложения, например ***OBS***.
    * Происходит ***балансировка нагрузки*** и данные попадают в очередь (***брокер сообщений***).
    
    * ***Кодировщик*** приводит данные в необходимый формат для последующей обработки в **микросервисной архитектуре**.
    
    * ***Микросервис распределения*** направляет данные о потоке и действиях через репозитории в **контейнеры**:
        * ***Кэш*** (Кэширует данные по ссылке).
        * ***Content Delievery Network*** (Получает ссылку, по которой подгружает данные из кэша, внутрення логика распределяет данные по регионам).
        * ***БД игр и адресов*** (Сохраняет ссылку и название игр трансляций).
        * ***Cloud Service*** (Получает команду о подгрузке данных из кэша).
    
    * ***API-сервис*** управляет взаимодеействием с внешними системами (Магазин, Страница игры):
        * Слушает **обновление БД** и забирает ссылку.
        * Отправляет ссылку в **CDN**, по которой забираются данные.
        * В случае запроса на загрузку направляет ссылку в **Cloud Service**. Забирает данные для загрузки.
    * ***Микросервис оповещения*** уведомляет пользователей о начале эфира:
        * Слушает **обновление БД** о начале нового потока и берет игру. 
        * Связывается с внешним **магазином** и получает **список пользователей**.
        * По данному списку через очередь **осуществляет рассылку уведомлений**.

* <u> ***Алгоритм решения***</u>: 
1. Настроить получение потока из ***OBS*** по протоколу ***RTSP***. Прописать ***Load Balancer (NginX)*** и ***брокер сообщений (Kafka)***.
2. Реализовать ***алгоритм кодировки*** формата видео для сжатия данных и перевода в нужный формат (***MP4*** или ***AVI***) Псевдокод:
```python
class VideoEncoder:
    def __init__(self, output_file = 'broadcast.mp4', *args, **kwargs):
        self.codec = fourcc(*"mp4v") # Формат видео-кодека
        self.out = VideoWriter(output_file, self.codec, *args, **kwargs) # Объект, куда будет записваться поток

    def encode_frame(self, frame):
        self.out.write(frame) # Кодирование кадра и запись
    
    def free_encoder(self):
        self.out.free() #Освободить ресурсы
    
    def save(self):
        self.out.save()

if __name__ == '__main__':
    data = 'link_data.format'
    encoder = VideoEncoder()
    for frame in data:
        encoder.encode_frame(frame)
    
    encoder.save()
    encoder.free()

# Внутренняя логика кодировщика
```
Пусть, есть класс **VideoEncoder**, который имеет атрибуты **codec** (формат) и **out** (то, что является результатом кодировки). Метод **encode_frame** записывает закодированный кадр, **free_encoder** - освобождает ресурсы, **save** - сохраняет для передачи в систему. Покадрово будет кодироваться видео, потом сохраняться и передавться по протоколу через брокер сообщений в систему. Тебе нужно превратить псевдокод в реализацию.

3. Реализовать внутреннюю логику ***микросервиса распределения***. 
* Запись в ***Кэш***.
```python
class VideoCacher:
    def __init__(self, link, data, cash_directory, *args, **kwargs):
        self.cache_dir = cash_directory # Файл/папка куда пишем кэш
        self.data = data
        self.link = link
        self.frames = {} # Словарь сслыка - видео

    def start_cache(self):
        self.frames[self.link] = [] # Новая запись

    def add_frame(self, frame):
        temp_frame_path = get_path(self.cash_dir) #Куда в этой директории будет писать кэш
        write(temp_frame_path, frame) #Записываем в кэш
        self.frames[link].append(temp_frame_path) # Добавляем ссылку на кадр.
    
    def write_cache(self): #Покадрово записать данные в кэш
        for frame in self.data:
            add_frame(frame)
    
    def clear_cache(self, link):
        clear_cache(link) #Очистка после чтения

if __name__ == '__main__':
    cache = VideoCacher(link, data, cash_directory)
    cache.start_cache()
    cache.write_cache() 

# Логика записи в кэш-память
```
Создаём класс **VideoCacher**, который будет записывать данные **link**<->**data** в **директорию cash_directory**. Соответственно перед началом кэширования будет объявляться по ключу массив ссылок на кадры. Это метод ***start_cache***. Затем покадрово делаем ***write_cache*** с использованием ***add_frame***. Чтение будет делать **Google Cloud** и **CDN**. Потом будет очищаться память. 
* Запись в ***БД игр и ссылок***.
```python 
class BroadcastInfo:
    def __init__(self, name, link):
        self.name = name
        self.link = link
    
    def empty_instance(self):
        if self.name != '':
            return True
        else:
            return False
    
if __name__ == '__main__':
    broadcast = BroadcastInfo(name, link) # Экземпляр класса инфо о трансляции
    directory_db = directory #Ссылка на БД
    insert_query = "INSERT INTO games (name, link) VALUES (%s, %s);"
    execute(insert_query, directory_db, (broadcast.name, broadcast.link)) # Записываем данные по сслыке
    close_connection() #Останавливаем соединение
```
* Также необходимо добавить ***подгрузку данных в облако Google Cloud*** при начале новой трансляции. Это можно сделать добавив дополнительную логику к предыдщему коду:
```python
    if broadcast.empty_instance() == True:
        read_query = f"SELECT * FROM cache WHERE link = {broadcast.link};"
        data = execute(read_query, cache_dir)
        write_in_cloud(broadcast.link, data) # Что-то вроде реализации записи в облако, откуда мы будем загружать
        # Соответственно нужно настроить связь с облачным сервисом
```
* ***Content Delievery Network*** будет получать ***link*** от broadcast и подгружать по этому ***link*** данные из ***кэша***.
```python
# Реализуется при помощи стандартных библиотек
import send_from_directory

@app.route('/content/<path:link>') 
def content():
    send_from_directory(cache_dir, broadcast.link) # Читает из кэша

if __name__ == '__main__':
    app.run(host = '0.0.0.0', port = 80)

# Какая-то такая реализация подгрузки данных из кэша
```
4. Реализовать ***API-сервис*** с внутренней логикой: загрузка данных из **Google Cloud**, **CDN** и **прослушивание обновления БД игр** для забора линков. Он же будет передвать инфу во внешние сервисы.
```python

db_games_fields = {parameters}
external_link = 'external_link_url'

def get_games_db_connect(db_games_fields): # Подключаемся к БД игр
    return connection(db_games_fields)

def get_new_links_from_db():
    connection = get_games_db_connect(db_games_fields)
    connection.execute("SELECT link FROM games WHERE processed = False;") # Запрос в БД
    new_records = get_from_games_db() # Забираем данные

    return new_records

def get_data_from_cdn(link):
    response = get_data_cdn(link)
    return response # Забрали данные

def send_broadcast(data):
    send(data, external_link) # Отправляем

def mark_record_as_processed(link): # Что-то вроде пометки конца операции
    connection.execute(f"UPDATE games SET processed = True WHERE link = {link};")
    connection.close() # Stop

app.route('/process-link')
def process_incoming():
    link = get_incoming_link()
    data = get_data_from_cloud_for_download(link) # Берем данные для загрузки в cloud

def main(): # Реализация логики
    while True:
        new_links = get_new_links_from_db()
        for link in new_links:
            data = get_data_from_cdn(link)
            send_broadcast(data)
            mark_record_as_processed(link)

if __name__ == '__main__':
    main()
    app.run(debug = True)

# Общая примерная реализация (Без углубленных знаний бэкэнда). 
```
Так, необходимо прописать на уровне ***API*** просмотр ***БД*** игр, забирать оттуда ссылку, по которой будем брать данные из ***CDN*** и отправлять куда-то во вне. Также на вход будет поступать извне ***link*** загрузки по ссылке, после чего будет загружаться файл (во внешней системе).

5. Реализовать ***систему уведомлений***:
```python

external_link = 'external_system_url'
connection = conncetion_games_db(games_db_fields) # Подключаемся к полям

def get_new_records():
    connection.execute("SELECT name FROM games WHERE processed = False;") # Запрос
    new_records = get_from_games_db() # Получаем данные
    return new_records

def get_users_from_extrenal_system(name):
    response = send(name, external_link) # отправляем
    return response

def mark_record_as_processed(name): # Что-то вроде пометки конца операции
    connection.execute(f"UPDATE games SET processed = True WHERE name = {name};")
    connection.close() # Stop

def send_message(users, name): # Отправляем месседж юзерам
    for users in users:
        print(f"Game {name} started the broadcast")

def main(): # Основная логика
    records = get_new_records()
    for name in records:
        users = get_users_from_extrenal_system(name)
        send_message(users, name)
        mark_record_as_processed(name)

if __name__ == '__main__':
    main()

# Примерно такая логика
```
>В целом, именно такая роспись задачи для junior-специалиста самая верная. В первой вообще ничего не понятно и джун будет тонуть. Во второй реализации наглядно описаны классы, функции и внешняя обёртка. Остаётся лишь воплотить псевдокод в жизнь! <br>
Говоря, о других постановках задач - они скорректированые до постановки по алгоритму.

## Задание 3.2.
### Short Review ###
>Задание заключается в постановке задачи по методике ***S-M-A-R-T***. Данный термин является аббревиатурой и включает в себя следующие особенности:
1. <u>***Specific*** (***Конкретность***):</u> <br>

<u>**Цель**</u> цель должна быть чётко сформулирована, чтобы она была ясна всем членам команды и не пришлось углубляться в детали.

2. <u>***Measurable*** (***Измеримая***)</u>: <br>

Должны быть чёткие <u>**критерии оценки**</u> достижения цели. Например, говоря про задачи машинного обучения - это конкретные метрики, удовлетворяющие бизнес-требованию (Классификация - **f1_score**, регрессия -  **MAE**, кластеризация - **silhouette** и так далее).

3. <u>***Achievable*** (***Достижимая***)</u>: <br>

Задача должна быть такой, чтобы она была <u>**выполнима**</u> для разработчика, кому предназначена. Например, нет смысла давать джуну неподъёмную задачу разработки какой-то архиважной для команды архитектуры нейронной сети на свежих данных для новой, никому не известной задаче. Джун просто будет тонуть.

4. <u>***Relevant*** (***Значимая***)</u>:

Задача должна быть ***важной*** и ***актуальной*** для команды или компании. То есть нужно ввести условного джуна в курс дела и разъяснить, что его работа не в стол и не холостая, а, например, решает бизнес-задачу: максимизирует прибыль, решает проблему заказчика, решает проблему организации и так далее.

5. <u>***Time-bound*** (***Ограниченность по времени***)</u>:

Задача должна иметь чёткие **сроки**. Например, если задача на "игру в долгую", например, не знаю, разработка криптовалюты, то мы говорим, что задача долгосрочная. А если у нас здесь и сейчас легло приложение, то задача восстановить его работу в максимально короткие сроки.

>Для постановки задачи по ***S-M-A-R-T*** выбрана ***система лотерей***

### Правильное решение ###

1. <u>***Specific*** (***Конкретность***):</u> <br>

* ***Что делаем?*** <br>

Система лотерей - система, которая будет выдавать пользователю/-ям сгенерированную случайную(или нет) игру в результате оплаты или на основе имеющихся игр. Этот продукт будет выбран для игры (процесса) или добавления в библиотеку.

* ***Что должно быть в нашей системе?***

    * **Лобби** - куда, добавляются пользователи.  **БД**, куда они записываются.
    * **Проверка авторизации** пользователей.
    * **Отправка уведомлений** пользователям на присоединение в лобби.
    * **Связка с библиотекой** членов лобби.
    * **Связка с магазином** игр через **фильтрацию** по жанрам, ценовой категории и так далее.
    * **Определение пула игр** по полученным данных. **БД** их записи.
    * **Рассчёт цены**. **БД цен**.
    * **Система оплаты**, связанная с платёжкой.
    * Механизм **генерации выигрыша**.

* ***Как всё взаимодейтсвует?*** 
    * Пользователь отправляет отправляет запрос в систему **лобби**.
    * **Лобби** добавляет **друзей**, **приглашает** их. Проверяет **авторизацию**. **Добавляет** их в БД. 
    *  Система **определения пула игр** связывается с **библиотекой** или **магазином** через механизм **фильтрации**. Добавляет их в **БД игры**.
    * **Механизм расчёта цены** берёт цены в **БД цен** и идёт в **оплату**.
    * **Оплата** берет список юзеров и общается с **платёжкой**. Успех перевод запрос в **генерацию выигрыша**.
    * **Генерация выигрыша** добавляет продукты в **библиотеку**.

2.  <u>***Measurable*** (***Измеримая***):</u> <br> 
    
Эффективность системы можно понять по следующим характеристикам:
* ***Время ответа системы*** : <br>

Допустим, есть максимальный **threshold** по **времени генерации выигрыша, задержки уведомлений или проведения оплаты**.

* ***Процент ложных срабатываний*** : <br>

Например, порог по ошибкам при включении игры из неверного **жанра, ценового диапазона, дупликата** и так далее.

* ***Максимальное количество пользователей при одном сеансе*** : <br>

**Максимальное число пользователей**, при котором система работает исправно и не ложится.

3. <u>***Achievable*** (***Достижимая***):</u> <br>

Задача может быть декомпозирована на сотрудников разного грейда. Например, дать джуну задачу строить сообщение с платёжкой или генерацию выигрыша, а у него скилл-лист это клепать CRUD'ы... С высокой долей вероятности он поплывет. Ему можно делегировать как раз записи и чтение из БД. Более сложные подфичи отдать на реализацию Senior'у или Middl'у.

4. <u>***Relevant*** (***Значимая***) :</u><br>

Значимость этой задачи заключается в повышении прибыли от рулеток, продвижении рахных игр и повышении выручки на душу игроков.

5. <u>***Time-bound*** (***Ограниченность по времени***) :</u> <br>

Так как фича не экстренная, но и не планиуруется что она должна принести прибыль в долгосроке (от 1-2 лет) есть смысл реализовать следущие сроки по дедлайнам: <br>
* Разработка ***лобби*** - 1 месяц.
* Связка с ***магазином и библиотекой*** - 2 недели.
* Система ***оплаты и генерация выигрыша*** - 1 месяц.
* ***Дедлайн фичи*** - 3 месяца.

### Неправильное решение ###

1. <u>***Non-Specific*** (***Отсутствие конкретности***):</u> <br>
    
Система лотерей - система, которая будет полезна пользователю(-ям) и будет давать им игры после оплаты или рандомно.

* ***Что должно быть в нашей системе?*** <br><br>
Система и её компоненты, чтобы пользователь мог воспользоваться функцией. Система оплаты и механизм генерации игры. 

* ***Как всё взаимодейтсвует?***  <br><br>
Пользователь делает запрос. Друзья добавляются в одно и то же место. Происходит оплата. Добавляется игра.

2. <u>***Non-Measurable*** (***Отсутствие чётких метрик***):</u> <br>

Система должна хорошо и качественно работать. Не ложиться.

3. <u>***Non-Achievable*** (***Недостижимая / Трудно достижимая***):</u> <br>

Все разработчки должны сделать всё возможное. Написать такой продукт, чтобы всё работало за O(1) и составляло 10% ВВП экономики России.

4. <u>***Non-relevant*** (***Значимость не обоснована***):</u> <br>
Ну мы делаем это, потому что это прикольно, стильно, модно, молодёжно. Потому что будет много details, будет песня.

5. <u>***No Time Limit*** (***Нет чётких временных границ***):</u> <br>
Сделаем, когда будет время.



